#+DATE: <2014-09-02 Tue>
#+OPTIONS: texht:t
#+LATEX_CLASS: snm-article
#+LATEX_CLASS_OPTIONS: [12pt]
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:


* Literate Emacs Configuration

Emacs comes with org-mode installed standard, which allows us to
create the emacs configuration in a well documented manner.

** Sources

-
- [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua emacs config]]

* The basics
** Force path to be consistent with terminal path

The mac behaves increasingly weird with relation to how paths are
being set in the terminal and in programs launched by  launchd (or by
extension Alfred).

In order to combat this I stole a trick from the Emacs wiki where the
path is obtained from a login shell, so it is guaranteed to be
consistent with the terminal. This will minimize surprises since I
like my editing environment to be identical to the shell environment.

#+BEGIN_SRC emacs-lisp
  (defun set-exec-path-from-shell-PATH ()
    "Sets the exec-path to the same value used by the user shell"
    (let ((path-from-shell
           (replace-regexp-in-string
            "[[:space:]\n]*$" ""
            (shell-command-to-string "$SHELL -l -c 'echo $PATH'"))))
      (setenv "PATH" path-from-shell)
      (setq exec-path (split-string path-from-shell path-separator))))

  ;; call function now
  (set-exec-path-from-shell-PATH)

#+END_SRC

#+RESULTS:
| /usr/local/bin | /usr/local/sbin | /usr/bin | /bin | /usr/sbin | /sbin | /opt/X11/bin | /usr/local/MacGPG2/bin | /Library/TeX/texbin | /usr/local/heroku/bin | /Users/pti/.sdkman/candidates/lazybones/current/bin | /Users/pti/.rvm/gems/ruby-2.1.2/bin | /Users/pti/.rvm/gems/ruby-2.1.2@global/bin | /Users/pti/.rvm/rubies/ruby-2.1.2/bin | /Users/pti/playpen/go/bin | /usr/local/opt/go/libexec/bin | /Users/pti/.rvm/bin | /Users/pti/bin | /Users/pti/.cargo/bin | /Users/pti/anaconda3/bin |


Tip: run the code above with C-C C-C to see the actual path being set
in the *RESULTS*.

** Package and Extension Management

Emacs has a package management system we'll be using to load the
extensions.

*** Setup repositories

By default emacs only comes with the elpa repository which is a bit
conservative.

Let's add the melpa repo to get the cutting-edge goodness.

#+BEGIN_SRC emacs-lisp
  ;; enable package repositories
  (add-to-list
  'package-archives
  '("melpa" . "http://melpa.milkbox.net/packages/") t)
#+END_SRC

#+RESULTS:

I used to have the marmalade repo configured too, but it's maintenance
has been patchy over the last years, so I removed it.
#+RESULTS:

*** Initialize Package Management

By default emacs initializes the packages after the user's init
scripts. The idea is that the variables are set before the package is
loaded.

However this also means we cannot call into the libraries.

#+BEGIN_SRC emacs-lisp
(package-initialize)
#+END_SRC

*** Add a helper to get libraries

This helper routine will install the package if it is not yet
installed and then *require* it so it is available for emacs.

#+BEGIN_SRC emacs-lisp
  (defun require-packages (&rest packages)
    (dolist (package packages)
      (unless (package-installed-p package)
        (package-install package))
      (require package)))
#+END_SRC

*** 3rd party extension loader

Not everything is nicely packaged up and available from the package
repositories.

Some extensions are available as a single file, some as git
repositories with an elisp file with the same name as entry point.

#+BEGIN_SRC emacs-lisp

  ;; add the vendor extension path to the load path
  (add-to-list 'load-path "~/.emacs.d/vendor")

  (defun vendor (library)
    "Load a vendor extension.
  Vendor extensions are loaded in an opinionated way. They will be
  present in ~/emacs.d/vendor folder. Either downloaded or as a git
  submodule.

  If it is a file with .el extension, or a folder with a file with
  the same basename and extension .el, then this will be placed on
  the load path and executed."

    (let* ((file (symbol-name library))
           (normal (concat "~/.emacs.d/vendor/" file))
           (suffix (concat normal ".el")))
      (cond
       ((file-directory-p normal)
        (add-to-list 'load-path normal)
        (require library))
       ((file-directory-p suffix)
        (add-to-list 'load-path suffix)
        (require library))
       ((file-exists-p suffix)
        (require library)))))
#+END_SRC

** Customization

Emacs comes with an extensive system for customizing the system and
the extra packages. The customization system collects this all in a
*custom.el* elisp file. Let's store that with the rest of our personal
preferences.

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/snamellit/custom.el")
(when (file-exists-p custom-file) (load custom-file))
#+END_SRC

** Setup registers for easy file access

Registers allow to quickly access stuff, in this case files.

Access the files using

 - C-x r j <register>

e.g.

 - C-x r j s  : access ~/.emacs.d/snamellit.org
 - C-x r j z  : open ~/.zshrc
 - C-x r j m  : open ~/org/melexis/melexis.org


#+BEGIN_SRC emacs-lisp
  (set-register ?s (cons 'file "~/.emacs.d/snamellit.org"))
  (set-register ?z (cons 'file "~/.zshrc"))
  (set-register ?m (cons 'file "~/org/melexis/melexis.org"))
#+END_SRC

#+RESULTS:
: (file . ~/org/melexis/melexis.org)

** Private information in separate file

Some things cannot be shared to the repo's so we also load a private
file which is added to the .gitignore file.

Here oauth keys and other private details can be stored.

#+BEGIN_SRC emacs-lisp
(setq private-file "~/.emacs.d/snamellit/private.el")
(when (file-exists-p private-file) (load private-file))
#+END_SRC

** Theming

I like the low contrast zenburn theme. Although I am also partial to
solarized dark. So I install both packages and keep them ready and
uncomment my current preference.

Note: zenburn is incompatible with ansiterm and insist on displaying
the content on a light background. I fixed it once, but it is broken
again so I switched back to solarized.

#+BEGIN_SRC emacs-lisp
  (require-packages 'zenburn-theme 'solarized-theme)
  (load-theme 'solarized-dark t)
  (load-theme 'solarized-light t)
  (load-theme 'zenburn t)
  (require-packages
   'color-theme
   'color-theme-solarized
   'color-theme-sanityinc-solarized)

  (color-theme-sanityinc-solarized-dark)

#+END_SRC

#+RESULTS:

I never use the toolbar, and seldom use the menu.

The toolbar especially is a waste of space.

I do like the scrollbars, not to use them for navigation, just to see
where I am in the file. When I feel particularly hard-core, I
sometimes tweak these settings.

#+BEGIN_SRC emacs-lisp
  ;; lose UI stuff
  ;(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  ;(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+END_SRC

** Garbage Collection Tuning

#+BEGIN_SRC emacs-lisp
;; garbage collection tuning
(setq gc-cons-threshold 20000000)  ;; 20Mb instead of 800k
#+END_SRC

** Temporary Files

Emacs creates temp files and backups. Auto build watchers and version
control tools and their users can get confused by this.

Let's move these to a separate folder.

Also never delete backup versions, keep backup files for files under
version control, add version numbers to the backup files.

Disk space is cheap but don't forget to clean out the backup
directory regularly.

#+BEGIN_SRC emacs-lisp
  ;; set the temporary files in a separate folder to avoid junk
  ;; in the work directories. Autobuilds and git will be happier.
  ;;
  ;; stolen from
  ;; http://github.com/febuiles/dotemacs/tree/master/temp_files.el

  (defvar user-temporary-file-directory "~/.emacs-autosaves/")

  (make-directory user-temporary-file-directory t)
  (setq backup-by-copying t)
  (setq delete-old-versions -1)
  (setq version-control t)
  (setq vc-make-backup-files t)
  (setq backup-directory-alist
        `(("." . ,user-temporary-file-directory)
          (,tramp-file-name-regexp nil)))
  (setq auto-save-list-file-prefix
        (concat user-temporary-file-directory ".auto-saves-"))
  (setq auto-save-file-name-transforms
        `((".*" ,user-temporary-file-directory t)))

#+END_SRC

** File Encodings

I decided a very long time ago that I only want to deal with UTF-8.

#+BEGIN_SRC emacs-lisp
(prefer-coding-system 'utf-8)
#+END_SRC

** Tramp remote editing

Change default mode from 'scp' to 'ssh' as this is faster.

#+BEGIN_SRC emacs-lisp

(setq tramp-default-method "ssh")

#+END_SRC

#+RESULTS:
: ssh


#+BEGIN_SRC emacs-lisp
(message "The basics done")
#+END_SRC
* Editing Environment

** Replace yes/no by y/n

From [[http://pages.sachachua.com/.emacs.d/Sacha.html#unnumbered-14][Sacha Chua's emacs config]].

Lazy people like me don't want to type *yes* or *no* when *y* or *n*
is ok.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

#+RESULTS:
: y-or-n-p

** Smart Mode line

The vi emulation can really benefit from the powerline port.

#+BEGIN_SRC emacs-lisp
  (require-packages 'smart-mode-line)
  (sml/setup)
#+END_SRC

#+RESULTS:
: t

** Vi emulation

Install evil mode as it is a very capable Vi emulation and allows
emacs to be used on the ipad.

However this clashes with org-mode, notably the tab handling, so
reset the keybindings with *evil-org* package.

#+BEGIN_SRC emacs-lisp
  ;; got bored of vi emulation
  ;(require-packages 'evil-leader 'evil 'evil-org)
  ;(evil-mode 1)
#+END_SRC

#+RESULTS:

the evil-org package provides following evil keybinding in Org

- gh    : go up a heading
- gj    : previous heading on same level
- gk    : next heading on same level
- gl    : go down the next visible level
- t     : create a todo item
- T     : convert heading to todo item
- H or ^: begin of line
- L or $: end of line
- > / < : promote/demote item
- -     : cycle list bullet
- TAB   : cycle org collapse nodes

with leader :

- t     : show todo tree
- a     : agenda
- c     : archive subtree
- l     : open links
- o     : update clocks

** Helm autocompletion mode

#+BEGIN_SRC emacs-lisp
  (require-packages 'helm)
  (require 'helm-config)

  ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
  ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
  ;; can't change `helm-command-prefix-key' once `helm-config' is loaded.
  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))

  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  (setq helm-split-window-in-side-p       t ; open helm buffer inside current window, not occupy whole other window
    helm-buffers-fuzzy-matching           t ; fuzzy matching buffer names when non--nil
    helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
    helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
    helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
    helm-ff-file-name-history-use-recentf t)

  ;; swap tab with C-z as tab is easier for frequent actions
  ; rebind tab to do persistent action
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  ; make TAB works in terminal
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
  ; list actions using C-z
  (define-key helm-map (kbd "C-z")  'helm-select-action)

  (helm-mode 1)
#+END_SRC


- C-c h i    : browse tags
- C-c h r    : regexp builder
- C-c h p    : browse emacs processes
- C-c h t    : browse top system processes
- C-c h C-,  : helm interface for calc

*** Helm M-x support

Helm has a feature to help completion in the command line. The normal
helm expansions now work over the interactive command set.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-x") 'helm-M-x)
#+END_SRC

#+RESULTS:
: helm-M-x

- Tab:    shows documentation of currently selected command

*** Helm kill ring support

Helm allows us to see the content of the kill ring and select using
its normal matchers the one we're interested in.

- M-y     show kill ring and allow helm selection.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
#+END_SRC

#+RESULTS:
: helm-show-kill-ring

*** Helm switch buffer/file support

Helm allows fancy selecting in the current buffers and the recent file
list.

helm-mini comprises of multiple sources:

- Current opening buffers, under the header Buffers.
- Recently opened files, under the header Recentf.
- Allow you to create a new buffer by pressing RET, under the header
Create Buffer.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x b") 'helm-mini)
#+END_SRC

#+RESULTS:
: helm-mini

- <left> <right>   : move between groups
- C-v M-v          : scroll up and down

You can filter out buffers by major mode using the pattern
*<major-mode>. For example, *dired narrows to only Dired buffers. You
can also filter out buffers that belong to a major mode by adding ! to
the pattern. For example, *!dired select all buffers that are not in
Dired mode.

You can also select buffers in a specific directory by using the
pattern /directory. For example, /.emacs.d/ narrows to buffers that
are only inside .emacs.d. Add ! before the pattern for reverse
version. For example, !/.emacs.d/ narrows to buffers not in .emacs.d.

You can even use helm-mini to narrow to buffers that contains a regexp
in their contents, by appending @ before the search pattern. For
example, you can select buffers that only contain the string "test":
@test. If you want to see the locations of the string in the buffers,
mark all the buffer with M-a and C-s while in helm-mini session, to
switch to helm-moccur. You can mark buffers to search by C-SPC. When
you switch to helm-moccur, matches that are in selected buffers are
displayed. You can also perform occur only on the current buffer with
prefix argument: C-u C-s; this is useful when you already marked
buffers but don't want to unmark just to view only in a
buffer. However, in general, you won't need C-u C-s.

Meaning of colors and prefixes for buffers:

- Remote buffers are prefixed with '@'.
- Red => Buffer have its file modified on disk by an external process.
- Indianred2 => Buffer exists but its file have been deleted.
- Orange => Buffer is modified and its file not saved to disk.
- Italic => A non-file buffer.

*** Helm find files support

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-f") 'helm-find-files)
#+END_SRC

helm-find-files is file navigation on steroids:

- helm-find-files can fuzzy match candidates in current directory. e.g
"fob" or "fbr" will complete "foobar".
- You can also execute persistent action, which is bound to C-z (by
default) or TAB if you use my configuration, to narrow the current
highlighting candidate; C-z or TAB again to view content of the
buffer. You can scroll the other buffer up/down by M-<next> and
M-<prior>.
- Alternatively, you can C-j to narrow to the highlighting candidate
and C-j again to view the content of other buffer. C-l to go back.
- You can also go up one directory level with C-l. NOTE: if you use
C-l, Helm goes up one level and the cursor is on the directory
you've just got out. If you want to go up and have the cursors on
the parent directory, in Helm prompt, enter ../.
- To create a directory, enter a new name that does not exist in the
current directory and append / at the end. After you created a
directory, Helm continues in that directory.
- To create a new file, enter a name and select the top row that has
the symbol [?] next to it. By default, Helm always selects the first
match in the directory.
- You can invoke grep on the current highlighting entry by C-s. C-u
C-s to perform recursive grep.
- Enter ~/ at end of pattern to quickly reach home directory.
- Enter / at end of pattern to quickly reach root of your file system.
- Enter ./ at end of pattern to quickly reach `default-directory'
(initial start of session). If you are in `default-directory' move
cursor on top.
- You can perform more actions on the highlighted entry by running
helm-select-action, which is bound to TAB by default and C-z in my
configuration. The guide for each action in the action menu is
written in the guide Exploring large projects with Projectile and
Helm Projectile. It is written there because you will end up using
Projectile (a project manage for Emacs, introduced in later section)
to navigate to files much more efficient, anywhere and anytime you
need.

**** Grep in find files

Within the find-files you can activate a grep with C-s.

- C-s : grep in files
- C-u C-s : grep in directory tree like rgrep

The following snippet uses ack instead of grep for improved
responsiveness.

#+BEGIN_SRC emacs-lisp
(when (executable-find "ack-grep")
(setq helm-grep-default-command "ack-grep -Hn --no-group --no-color %e %p %f"
    helm-grep-default-recurse-command
    "ack-grep -H --no-group --no-color %e %p %f"))
(when (executable-find "ack")
(setq helm-grep-default-command "ack -Hn --no-group --no-color %e %p %f"
    helm-grep-default-recurse-command
    "ack -H --no-group --no-color %e %p %f"))
#+END_SRC

#+RESULTS:
: ack -H --no-group --no-color %e %p %f

*** Helm access to mark ring

Marks allow fast navigation between points in the codebase, however
this gets confusing after some marks are active. This extension allows
you to search for marks with a helm interface.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
#+END_SRC

#+RESULTS:
: helm-all-mark-rings

- C-h SPC   : browse the mark ring

*** helm support for emacs registers

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c h x") 'helm-register)
#+END_SRC

#+RESULTS:
: helm-register

** helm interface for expression with eldoc

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c h M-:") 'helm-eval-expression-with-eldoc)
#+END_SRC

#+RESULTS:
: helm-eval-expression-with-eldoc

** resize windows with C-S-arrowkey

The normal keybindings for resizing windows are :

 - C-x ^ : increase vertical size
 - C-x } : increase horizotal size

With ESC-number this is doable, but not very friendly : this is a
control sequence to the bottom of the keyboard followed by a shift +
top row key.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
  (global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
  (global-set-key (kbd "S-C-<down>") 'shrink-window)
  (global-set-key (kbd "S-C-<up>") 'enlarge-window)
#+END_SRC

#+RESULTS:
: enlarge-window

Note that these keybindings are overriddden in org-mode buffers. In
practice this is seldom a problem : go to another, non-org window and
resize that.

** control menus with lacarte

Lacarte allows fast access to menu and other commands.

There are 2 variants, one which uses the function names and the other
which uses the menu structure

 - ESC M-x : execute menu commands by function name
 - M-` : execute menu commands by menu structure

#+BEGIN_SRC emacs-lisp
  (require-packages 'lacarte)
  (global-set-key [?\e ?\M-x] 'lacarte-execute-command)
  (global-set-key [?\M-`] 'lacarte-execute-menu-command)
#+END_SRC

#+RESULTS:
: lacarte-execute-menu-command


#+BEGIN_SRC emacs-lisp
(message "editing environment done")
#+END_SRC
* General

** EditorConfig support

There is a new movement to provide cross platform/editor support for
editor settings in IDE/Editors to make the life with linters more easy
for multi person teams (and that include single person teams working
back after an hiatus).

#+BEGIN_SRC emacs-lisp
  (require-packages 'editorconfig)
  (editorconfig-mode 1)
#+END_SRC

#+RESULTS:
: t

** Whitespace handling

*** Trailing white space

One of the minor nuisances is that spaces tend to invisibly collect at
the end of lines. Let's get rid of it before saving.

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

*** TODO Tabs in source code

TODO: figure out an overridable way to untabify buffers.

I like a tab-width of 2 by default. This is typically overriden by the
minor modes of specific languages, but 2 is a sensible default.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 2)
#+END_SRC

There is a debate over the use of tabs in source code. Some people
argue for the use of tabs, others against.

I consider tabs to be chaos spawn and thoroughly evil, so they need to
be dealt with swiftly and severely.

There is no way to have consistent formatting with tabs with multiple
editors and multiple people. Combine that with different conventions
of tab width in different environments and different ways to
interpolate between tab positions and the chaos is complete.

So I do not want that emacs insert tabs when indenting and just in
case I replace all tabs with spaces before saving.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (defun untabify-buffer ()
    "Untabify current buffer"
    (interactive)
    (save-excursion
      (untabify (point-min) (point-max)))
    nil)

  (defun add-untabify-before-save ()
    "Add an untabify action to the local write content hook"
    (add-hook 'write-content-hook 'untabify-buffer nil t))
#+END_SRC

#+RESULTS:
: add-untabify-before-save

Note that in files relying on tabs, we must remove this hook
again. Only *Makefiles* and tab separated files come to mind.

** Snippets

Enable *yasnippet* globally

#+BEGIN_SRC emacs-lisp
(require-packages 'yasnippet)
(eval-after-load "yasnippet"
'(yas-global-mode 1))
#+END_SRC

However snippets wreak havoc in terminals, especially with tab
expansion. Let's disable it there.

#+BEGIN_SRC emacs-lisp
;; disable YAS in terminals
(add-hook 'term-mode-hook (lambda () (yas-minor-mode -1)))
#+END_SRC

** Multiple Cursors

A cool feature introduced by Sublime are multiple cursors.

It did not take long before this was ported to emacs

#+BEGIN_SRC emacs-lisp
(require-packages 'multiple-cursors)
(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
(global-set-key (kbd "C->") 'mc/mark-next-like-this)
(global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
#+END_SRC

** Expand Region

IntelliJ has a cool feature that a single keystroke switches the
selected region from word --> sentence --> paragraph --> ... and back
again. Similar for blocks in programming languages.

 - C-= : expand region

#+BEGIN_SRC emacs-lisp
  (require-packages 'expand-region)
#+END_SRC

#+RESULTS:
: er/expand-region

** Emacs Server
In order to use emacs for quick and dirty edits it is useful to start
the editing server in the background.

This allows me to use emacs as an editor for commit messages without
each time having the overhead of starting all the packages.

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

** Auto Completion

#+BEGIN_SRC emacs-lisp
  (require-packages 'company)
  (add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

#+RESULTS:
| global-company-mode |

** Syntax checking

#+BEGIN_SRC emacs-lisp
  (require-packages 'flycheck)
#+END_SRC

#+RESULTS:

** Rainbow Delimiters

#+BEGIN_SRC emacs-lisp
(require-packages 'rainbow-delimiters)


#+END_SRC

** Comment Regions

Global mapping to comment and uncommenting

#+BEGIN_SRC emacs-lisp
; comment and uncomment regions
(global-set-key (kbd "C-/") 'comment-region)
(global-set-key (kbd "C-?") 'uncomment-region)
#+END_SRC

#+RESULTS:
: uncomment-region

** Quickly jump in document with ace-jump-mode

#+BEGIN_SRC emacs-lisp
  (require-packages 'ace-jump-mode)
  (define-key global-map (kbd "C-`") 'ace-jump-mode)
#+END_SRC

#+RESULTS:
: ace-jump-mode

** Move kill-region away from s-x

On the macbook pro there are 4 rather small keys next to each other,
Fn, Ctrl, Option and Cmd. Unfortunately Cmd-x is very easily typed by
me instead of Option-x to launch a command. This usually coincides
with a sizable chunk of text dissappearing as it is mapped to
*kill-region*.

This was very frustrating and a time waster. So unbind this key.

#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "s-x"))
#+END_SRC

** Emacs Lisp limits

Stock emacs has defaults which are rather small for historical reasons.

The max-lisp-eval-depth limits the recursion. Enlarging it allows to
use the tail-recursion pattern which are not optimized in emacs-lisp.

The max-specpdl-size limits the number of variable-binding and
unwind-protects.

#+BEGIN_SRC emacs-lisp
(setq max-lisp-eval-depth 20000)
(setq max-specpdl-size 30000)
#+END_SRC

** GNU Global tags

#+BEGIN_SRC emacs-lisp
  (require-packages 'ggtags)
  (add-hook 'c-mode-common-hook
            (lambda ()
              (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
                (ggtags-mode 1))))
#+END_SRC

#+RESULTS:
| lambda | nil | (when (derived-mode-p (quote c-mode) (quote c++-mode) (quote java-mode)) (ggtags-mode 1)) |




#+BEGIN_SRC emacs-lisp
(message "general done.")
#+END_SRC

* Programming Languages

** Clojure


*** Clojure language support

Enable clojure-mode and add support for clojurescript.



#+BEGIN_SRC emacs-lisp
(require-packages 'paredit 'clojure-mode)
(add-to-list 'auto-mode-alist '("\.cljs$" . clojure-mode))
(add-hook 'clojure-mode-hook 'paredit-mode)
(add-hook 'clojure-mode-hook 'rainbow-delimiters-mode)
(add-hook 'clojure-mode-hook 'add-untabify-before-save)
#+END_SRC

*** Cider REPL integration

Enable the Cider package to connect to the nRepl's of running clojure apps.

Enable paredit and rainbow delimiters in the repl. We also let the
clojure syntax highlighter work in the repl.

#+BEGIN_SRC emacs-lisp
  (require-packages 'cider)
  (add-hook 'cider-repl-mode-hook 'paredit-mode)
  (add-hook 'cider-repl-mode-hook 'rainbow-delimiters-mode)
  (setq cider-repl-use-clojure-font-lock t)
  (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
#+END_SRC

I also enabled the eldoc mode with cider.

#+RESULTS:
: t

** Groovy

See [[http://groovy.codehaus.org/Emacs%2BGroovy%2BMode][the emacs guidelines on the groovy website]].

#+BEGIN_SRC emacs-lisp
  (require-packages 'groovy-mode )

  ;;; use groovy-mode when file ends in .groovy or has #!/bin/groovy at start
  (autoload 'groovy-mode "groovy-mode" "Major mode for editing Groovy code." t)
  (add-to-list 'auto-mode-alist '("\.groovy$" . groovy-mode))
  (add-to-list 'interpreter-mode-alist '("groovy" . groovy-mode))

  ;;; make Groovy mode electric by default.
  (add-hook 'groovy-mode-hook
            '(lambda ()
               (require 'groovy-electric)
               (groovy-electric-mode)
               (add-untabify-before-save)))
#+END_SRC

** Go

Go mode used to be shipped with the Go language, however this has
stopped with Go 1.4 and later. The canonical place for go-mode is
github and an up-to-date version is available from melpa.

#+BEGIN_SRC emacs-lisp
  (require-packages 'go-mode
                    'go-eldoc
                    'go-projectile
                    'go-snippets)
#+END_SRC

#+RESULTS:

** Lisp

*** Slime mode

#+BEGIN_SRC emacs-lisp
  (require-packages 'slime)
  (setq inferior-lisp-program "/usr/local/bin/sbcl")
  (setq slime-contribs '(slime-fancy slime-js)) ; almost everything
  (slime-setup '(slime-fancy slime-asdf slime-js))

#+END_SRC

#+RESULTS:

** Javascript

*** js2-mode

For javascript, Steve Yegge's js2-mode is recommended over the version shipped with emacs.

#+BEGIN_SRC emacs-lisp
  (require-packages 'js2-mode 'js2-refactor)

  (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
  (add-to-list 'interpreter-mode-alist '("node" . js2-mode))

  (setq js-indent-level 2)
  (setq js-indent-first-init "dynamic")

  (js2r-add-keybindings-with-prefix "C-c C-m")

  (add-hook 'js2-mode-hook
            (lambda ()
              (set (make-local-variable 'indent-tabs-mode) 'nil)
              (set (make-local-variable 'js-indent-level) 2)
              (set (make-local-variable 'tab-width) 2)
              (add-untabify-before-save)))

#+END_SRC

#+RESULTS:
| (lambda nil (set (make-local-variable (quote indent-tabs-mode)) (quote nil)) (set (make-local-variable (quote js-indent-level)) 2) (set (make-local-variable (quote tab-width)) 2) (add-untabify-before-save)) | (lambda nil (set (make-local-variable (quote indent-tabs-mode)) (quote nil)) (set (make-local-variable (quote tab-width)) 2) (add-untabify-before-save)) | skewer-mode | add-untabify-before-save | er/add-js2-mode-expansions | er/add-js-mode-expansions |

To customize how it works: *M-x customize-group RET js2-mode RET*.

I also enabled the js2-refactor package.

*** swank-js

see [[https://github.com/swank-js/swank-js][SwankJS github repo]] for more details.

Install Node.JS and npm using your favorite package manager.

Install swank-js from npm:

#+BEGIN_SRC sh
  npm install -g swank-js
#+END_SRC

Now enable swank-js in emacs

#+BEGIN_SRC emacs-lisp

  (global-set-key [f5] 'slime-js-reload)
  (add-hook 'js2-mode-hook
            (lambda ()
              (slime-js-minor-mode 1)))

  ;; for css mode support
  (add-hook 'css-mode-hook
            (lambda ()
              (define-key css-mode-map "\M-\C-x" 'slime-js-refresh-css)
              (define-key css-mode-map "\C-c\C-r" 'slime-js-embed-css)))

#+END_SRC

#+RESULTS:
| (lambda nil (define-key css-mode-map \230 (quote slime-js-refresh-css)) (define-key css-mode-map  (quote slime-js-embed-css))) | skewer-css-mode | add-untabify-before-save |


*** Live Browser Interaction with skewer-mode

For live interaction there is *skewer-mode* which is
installed. Installation is done in the integration section as it is
also used by CSS and HTML modes.

The keybindings for evaluating expressions in the browser are just
like the Lisp modes. These are provided by the minor mode skewer-mode.

- C-x C-e: Evaluate the form before the point and display the result
in the minibuffer. If given a prefix argument, insert the result
into the current buffer.
- C-M-x: Evaluate the top-level form around the point.
- C-c C-k: Load the current buffer.
- C-c C-z: Select the REPL buffer.

The result of the expression is echoed in the minibuffer.

** Lisp

*** Paredit Mode

Paredit allows you to enter lisp code where it is actually impossible
to write syntax errors. With all the parentheses in lisp this is
actually one of the killer apps in Emacs.

Enable it when editing emacs lisp and also enable highlighting parens.

#+BEGIN_SRC emacs-lisp
(autoload 'paredit-mode "paredit"
   "Minor mode for pseudo-structurally editing Lisp code."
   t)
(add-hook 'emacs-lisp-mode-hook
        (lambda ()
          (paredit-mode +1)
          (show-paren-mode +1)
          (add-untabify-before-save)))

#+END_SRC

#+RESULTS:
| lambda | nil | (paredit-mode 1) | (show-paren-mode 1) |

** Elixir

Elixir has good tooling in emacs.

*elixir-mode* is actively maintained to add language support to emacs.

*alchemist* contains the elixir tooling integration. It provides
access to the *iex* shell, adds interactive help based on iex so it is
always accurate with the installed elixir, and of course support for
the *mix* build system.

The older *elixir-mix* package has been included in *alchemist* and is
now considered obsolete : it is no longer maintained.

There is a snippet collection in *elixir-yasnippets*

#+BEGIN_SRC emacs-lisp
;; elixir-mode : basic elixir editing support
;; elixir-yasnippets : predefined elixir snippets
;; alchemist : mix and other elixir tool integration
;; Note : elixir-mix is included in alchemist and obsolete now
(require-packages 'alchemist 'elixir-mode 'elixir-yasnippets)

;; add a hook to compile on save
(defun elixir-mode-compile-on-save ()
"Elixir mode compile files on save."
  (and (file-exists (buffer-file-name))
       (file-exists (elixir-mode-compiled-file-name))
           (elixir-cos-mode t)))
(add-hook 'elixir-mode-hook 'elixir-mode-compile-on-save)


;; enable to let mix run the test suite on save
(setq alchemist-hooks-test-on-save t)

#+END_SRC

#+RESULTS:
| elixir-mode-compile-on-save | alchemist-mode-hook |

** TODO Python

This is very 'light' for python development. Especially with plone
there is ample room for more support here.

On the other hand the include python mode works quite well out of the box.

#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook 'add-untabify-before-save)
#+END_SRC
*** Shortcuts


- C-c C-p:   Run python repl
- C-c C-c:   Execute current buffer in python
- C-c C-v:   Syntax check with pyflakes
- C-c C-z:   Switch to python shell

- C-c <:     Indent left
- C-c >:     Indent right

Skeletons :
- C-c C-t c: class
- C-c C-t d: function definition
- C-c C-t f: for loop
- C-c C-t i: if statement
- C-c C-t m: import
- C-c C-t t: try catch
- C-c C-t w: while loop

*** Virtualenv support

#+BEGIN_SRC emacs-lisp
  (require-packages 'virtualenvwrapper)
  (venv-initialize-interactive-shells) ;; if you want interactive shell
                                       ;; support
  (venv-initialize-eshell) ;; if you want eshell support

  ;; where are the virtual environments?

  ;; when a single path is given then the packages assumes
  ;; all virtualenvs are in this folder.
  (setq venv-location (concat
                       (getenv "HOME")
                       "/playpen/python"))

  ;; when a list of paths is given, then each path should point to a
  ;; virtualenv. All of them must have a unique folder name (the last
  ;; part of the path) as that is used to find the right virtualenv to
  ;; activate
  ;; (setq venv-location
  ;;   '("/Users/pti/Nitrous/snamellit-6031/python-100545/itbiusers"
  ;;     "/Users/pti/projects/vcs-adapter"))

#+END_SRC

#+RESULTS:
: /Users/pti/playpen/python

*** TODO Auto completion and docs with Jedi

#+BEGIN_SRC emacs-lisp
  (require-packages 'jedi)
  (add-hook 'python-hook-mode 'jedi:setup)
  (setq jedi:complete-on-dot t)

#+END_SRC


*** TODO Kind of Electric newlines

Indent after a new line.

#+BEGIN_SRC emacs-lisp
;; indent after newline
(add-hook 'python-mode-hook
        '(lambda ()
           (define-key python-mode-map "\C-m" 'newline-and-indent)))
#+END_SRC

However, this seems so _cuddly_ that there must be a better way

The standard C-j electric newline does not seem to do what I want. It
behaves weird.

*** Django Support

#+BEGIN_SRC emacs-lisp
  (require-packages 'python-django)
#+END_SRC

#+RESULTS:


*** Python unit testing with nose

#+BEGIN_SRC emacs-lisp
(require-packages 'nose)
#+END_SRC

*** IPython Notebook Support

#+BEGIN_SRC emacs-lisp
  (require-packages 'ein)

#+END_SRC

#+RESULTS:

** TODO Ruby

*** TODO Enable some electric features

TODO : split this in multiple sections to explain the use of the
different packages

Enable electric mode and reindent after a newline.

Also force tab settings just in case.

#+BEGIN_SRC emacs-lisp
  (require-packages 'ruby-electric 'ruby-additional 'ruby-compilation
                    'ruby-refactor 'ruby-test-mode)

  ; where'd this go?
  (defun ruby-reindent-then-newline-and-indent ()
    "Reindents the current line then creates an indented newline."
    (interactive "*")
    (newline)
    (save-excursion
      (end-of-line 0)
      (indent-according-to-mode)
      (delete-region (point) (progn (skip-chars-backward " \t") (point))))
    (when (ruby-previous-line-is-comment)
        (insert "# "))
    (indent-according-to-mode))

  (defun ruby-previous-line-is-comment ()
    "Returns `t' if the previous line is a Ruby comment."
    (save-excursion
      (forward-line -1)
      (ruby-line-is-comment)))

  (defun ruby-line-is-comment ()
    "Returns `t' if the current line is a Ruby comment."
    (save-excursion
      (beginning-of-line)
      (search-forward "#" (point-at-eol) t)))

  (add-hook 'ruby-mode-hook
            (lambda ()
              (set (make-local-variable 'indent-tabs-mode) 'nil)
              (set (make-local-variable 'tab-width) 2)
              (define-key ruby-mode-map "\C-m" 'ruby-reindent-then-newline-and-indent)
              (ruby-electric-mode t)
              (add-untabify-before-save)))
#+END_SRC

*** Add ruby support to popular file types

#+BEGIN_SRC emacs-lisp
; ruby
(setq auto-mode-alist (cons '("Rakefile" . ruby-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("Capfile" . ruby-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.rake" . ruby-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.god" . ruby-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.ru" . ruby-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.gemspec" . ruby-mode) auto-mode-alist))
#+END_SRC

*** DONE Integrate with RVM

I use RVM to manage my ruby versions independently from the
system. This eases cross machine development and cross project
dependencies.

#+BEGIN_SRC emacs-lisp

(require-packages 'rvm)

(add-hook 'ruby-mode-hook
        (lambda () (rvm-activate-corresponding-ruby)))
#+END_SRC

By setting the corresponding ruby, the live interaction will see the
same ruby environment as the project I am working on.

*** Testing with RSpec

#+BEGIN_SRC emacs-lisp
(require-packages 'rspec-mode)
#+END_SRC

#+RESULTS:

**** Additional snippets for RSpec

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'rspec-mode
    '(rspec-install-snippets))
#+END_SRC

#+RESULTS:

**** RSpec mode and ZSH and RVM

If you use ZSH and RVM, you may encounter problems running the
specs. It may be so that an older version of Ruby, than the one you
specified in .rvmrc, is used. This is because ZSH runs a small script
each time a shell is created, which modifies the $PATH. The problem is
that it prepends some default paths, such as /usr/bin, which contains
another ruby binary.

What you can do to solve this is to use BASH for running the
specs. This piece of code does the job:


#+BEGIN_SRC emacs-lisp
  (defadvice rspec-compile (around rspec-compile-around)
    "Use BASH shell for running the specs because of ZSH issues."
    (let ((shell-file-name "/bin/bash"))
      ad-do-it))

  (ad-activate 'rspec-compile)
#+END_SRC

#+RESULTS:
: rspec-compile

** TODO Scala

this is very sparse.

OTOH I do very little scala atm, so I'll look at it later.

#+BEGIN_SRC emacs-lisp
  (require-packages 'scala-mode)
  (add-hook 'scala-mode-hook 'add-untabify-before-save)
#+END_SRC

** TODO Rust

#+BEGIN_SRC emacs-lisp
  (require-packages 'flycheck-rust 'racer 'company-racer 'rust-mode)

  (setq racer-cmd "/Users/pti/.cargo/bin/racer")
  (setq racer-rust-src-path "/Users/pti/playpen/rust/rust/src")

  (add-hook 'rust-mode-hook #'racer-mode)
  (add-hook 'racer-mode-hook #'eldoc-mode)
  (add-hook 'racer-mode-hook #'company-mode)

  (global-set-key (kbd "TAB") #'company-indent-or-complete-common) ;
  (setq company-tooltip-align-annotations t)
#+END_SRC

#+RESULTS:
: t

** Shell

#+BEGIN_SRC emacs-lisp
(add-hook 'shell-mode-hook 'add-untabify-before-save)
#+END_SRC

*** Configure ansi shell

Enable ansi color and tell apps to use utf-8.

#+BEGIN_SRC emacs-lisp
;; on the mac we need to tell the apps launched to use utf8
;; as the character encoding
(defadvice ansi-term (after advise-ansi-term-coding-system)
  (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
(ad-activate 'ansi-term)

(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
#+END_SRC

Note:

on the Mac, it is possible that the eterm-color terminfo is
missing.

This causes the lines in zsh to start with '4m' and generally
the terminal behaves weird when wrapping.

In this case create a folder ~/.terminfo and run

#+BEGIN_SRC sh
cd
mkdir .terminfo
tic -o .terminfo /Applications/Emacs.app/Contents/Resources/etc/e/eterm-color.ti
#+END_SRC

on the command line.

after restarting the ansi-shell the terminal will behave a lot
better

Note that the ansi term buffer uses 2 modes :

- C-c C-k  :  character mode
- C-c C-j  :  line mode

While in line mode the buffer behaves more as a real text buffer and
allows copy pasting stuff. In character mode it behaves more like a
real terminal, with the keybindings used in the terminal, but it is
more isolated from the rest of emacs.

*** Tell launched apps to use utf-8

#+BEGIN_SRC emacs-lisp
;; on the mac we need to tell the apps launched to use utf8
;; as the character encoding
(defadvice ansi-term (after advise-ansi-term-coding-system)
  (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
(ad-activate 'ansi-term)
#+END_SRC

*** Allow history to work in  shell

#+BEGIN_SRC emacs-lisp
(eval-after-load 'shell
'(progn
   (define-key shell-mode-map [up] 'comint-previous-input)
   (define-key shell-mode-map [down] 'comint-next-input)
   (define-key shell-mode-map "\C-p" 'comint-previous-input)
   (define-key shell-mode-map "\C-n" 'comint-next-input)))
#+END_SRC

** Languages done
#+BEGIN_SRC emacs-lisp
(message "languages done")
#+END_SRC

* Web Development
** Web Templates

#+BEGIN_SRC emacs-lisp
  (require-packages 'web-mode)
  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[gj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))

  (add-hook 'web-mode-hook 'add-untabify-before-save)

  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)

  (setq web-mode-style-padding 1)
  (setq web-mode-script-padding 1)

#+END_SRC

#+RESULTS:
: 1

*** Shortcuts for web-mode

**** General

C-c C-; comment / uncomment line(s)
C-c C-f toggle folding on a tag/block
C-c C-i indent entire buffer
C-c C-m mark and expand
C-c C-s insert snippet
C-c C-w toggle display of invalid whitespaces

**** DOM

C-c C-d d show tag mismatch
C-c C-d e replace HTML entities
C-c C-d n normalize
C-c C-d q replace dumb quotes
C-c C-d t traverse dom tree
C-c C-d x xpath

**** Block

C-c C-b c block close
C-c C-b b block beginning
C-c C-b e block end
C-c C-b p previous block
C-c C-b n next block
C-c C-b k block kill
C-c C-b s block select

**** HTML element

C-c / element close
C-c C-e b element beginning
C-c C-e c element clone
C-c C-e d child element (down)
C-c C-e e element end
C-c C-e i select element content (inner)
C-c C-e k element kill
C-c C-e n next element
C-c C-e p previous element
C-c C-e r rename element
C-c C-e s select element
C-c C-e u parent element (up)
C-c C-e u element vanish

**** HTML tag

C-c C-t a sort attributes
C-c C-t b tag beginning
C-c C-t e tag end
C-c C-t m fetch matching tag (also available for active blocks)
C-c C-t s select tag
C-c C-t p previous tag
C-c C-t n next tag

**** HTML attribute

C-c C-a b attribute beginning
C-c C-a e attribute end
C-c C-a s attribute select
C-c C-a t attribute transpose
C-c C-a n attribute next

** CSS

Set tabwidth to my preferred 2 spaces for CSS.

#+BEGIN_SRC emacs-lisp
(setq css-mode-indent-depth 2)

(add-hook 'css-mode-hook 'add-untabify-before-save)
#+END_SRC

#+RESULTS:
: 2

*** Live browser integration

Send CSS declarations directly to the browser using *skewer-mode*
(installed in the integration section).

- C-x C-e: Load the declaration at the point.
- C-M-x: Load the entire rule around the point.
- C-c C-k: Load the current buffer as a stylesheet.

** Sass

Load SCSS mode for Sassy support

#+BEGIN_SRC emacs-lisp
(require-packages 'scss-mode)

(add-hook 'scss-mode-hook 'add-untabify-before-save)
#+END_SRC

** Rails
*** Rinari is no a Rails IDE

Another cute acronym.

#+BEGIN_SRC emacs-lisp
; rinari
(setq rinari-tags-file-name "TAGS")
(add-hook 'rinari-minor-mode-hook
        (lambda ()
          (define-key
            rinari-minor-mode-map
            (kbd "A-r")
            'rinari-test)))
#+END_SRC

*** Enable ruby support in rails templates

#+BEGIN_SRC emacs-lisp
; rhtml
(add-to-list 'auto-mode-alist '("\\.html\\.erb\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
#+END_SRC

** Mustache

Map mustache files to template mode

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
#+END_SRC

** Plone

*** Support .zcml config files

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.zcml$" . nxml-mode))
#+END_SRC

#+RESULTS:

** Web Development done
#+BEGIN_SRC emacs-lisp
  (message "web development section done")
#+END_SRC

* Content Creation

** Org Mode

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/org")
#+END_SRC

#+RESULTS:
: ~/org

*** Add contrib directory if available

The contrib directory is not shipped with emacs or with the org
packages.

So I added the git repository to the vendor extensions and then add
the contrib directory included in there to the load path.

#+BEGIN_SRC emacs-lisp
  ;;  (if (file-exists-p "~/.emacs.d/vendor/org-mode")
  ;;      (add-to-list 'load-path "~/.emacs.d/vendor/org-mode/contrib/lisp")
  ;;    (message "org-mode not present in vendor extensions"))

#+END_SRC

**** TODO Fix conflict with org-jira

Currently I commented this out to fix a conflict with elpa's
org-jira. The contrib folder also contains a stub implementation of
org-jira which masks the elpa one.

I also change the taskjuggler integration to directly load the code
from the contrib folder rather than putting the contrib folder on the
search path.

*** Global keybindings

In order to use org mode effectively we need easy access from anywhere
in emacs.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

#+RESULTS:
: org-iswitchb

*** Org mode TODO Keywords

#+BEGIN_SRC emacs-lisp
(setq
org-todo-keywords
(quote
((sequence "TODO(t)" "NEXT(n)"
           "|" "DONE(d!/!)")
 (sequence "WAITING(w@/!)" "SOMEDAY(s!)"
           "|" "CANCELLED(c@/!)" "PHONE")
 (sequence "OPEN(O!)"
           "|" "CLOSED(C!)"))))

(setq org-todo-keyword-faces
    (quote (("TODO" :foreground "red" :weight bold)
            ("NEXT" :foreground "blue" :weight bold)
            ("DONE" :foreground "forest green" :weight bold)
            ("WAITING" :foreground "orange" :weight bold)
            ("SOMEDAY" :foreground "magenta" :weight bold)
            ("CANCELLED" :foreground "forest green" :weight bold)
            ("OPEN" :foreground "blue" :weight bold)
            ("CLOSED" :foreground "forest green" :weight bold)
            ("PHONE" :foreground "forest green" :weight bold))))

(setq org-todo-state-tags-triggers
    (quote (("CANCELLED"
             ("CANCELLED" . t))
            ("WAITING"
             ("WAITING" . t))
            ("SOMEDAY"
             ("WAITING" . t))
            (done
             ("WAITING"))
            ("TODO"
             ("WAITING")
             ("CANCELLED"))
            ("NEXT"
             ("WAITING"))
            ("DONE"
             ("WAITING")
             ("CANCELLED")))))

#+END_SRC

*** enable autofill mode

Enable autofill in org-buffers to help with keeping the t
#+BEGIN_SRC emacs-lisp
(require-packages 'fill-column-indicator)
(add-hook
'org-mode-hook
(lambda ()
 (auto-fill-mode)
 (fci-mode)))
(setq fci-rule-width 1)
(setq fci-rule-color "cornsilk4")
#+END_SRC

#+RESULTS:
: cornsilk4

*** Capture templates

Add some templates for quick capture of things to organize.

The global keycode to add a thing is

- C-c c

This shows a nice menu with things to add. When choosing one of the
things a fill in template is provided.

- C-c C-c will file it once it is done.
- C-c C-w finalize by refiling it.
- C-c C-k abort the capture process.

#+BEGIN_SRC emacs-lisp

(setq org-default-notes-file (concat org-directory "/notes.org"))

#+END_SRC

The following template are provided:

- todo: a todo in refile.org
- note: a note in refile.org
- journal: a note in diary.org
- review: a review todo in refile.org
- phone: a phonec call
- habit: a habit entry

#+BEGIN_SRC emacs-lisp


#+END_SRC

#+RESULTS:
| t | todo         | entry | (file ~/org/refile.org)         | (concat * TODO %?\n %U\n %a\n   %i)                                                         | :clock-in         | t | :clock-resume | t |
| n | note         | entry | (file ~/org/refile.org)         | (concat * %? :NOTE:\n %U\n %a\n)                                                            |                   |   |               |   |
| j | Journal      | entry | (file+datetree ~/org/diary.org) | (concat * %?\n %U\n   %i)                                                                   | :clock-in         | t | :clock-resume | t |
| w | org-protocol | entry | (file ~/org/refile.org)         | (concat * TODO Review %c\n %U\n   %i)                                                       | :immediate-finish | t |               |   |
| p | Phone call   | entry | (file ~/org/refile.org)         | (concat * PHONE %? :PHONE:\n %U\n   %i\n)                                                   | :clock-in         | t | :clock-resume | t |
| h | Habit        | entry | (file ~/org/refile.org)         | (concat * TODO %?\n %U\n %a\n :SCHEDULED: %t\n :PROPERTIES:\n :STYLE: habit\n :END:\n   %i) |                   |   |               |   |

In these entries, the first string is the key to reach the template,
the second is a short description. Then follows the type of the entry
and a definition of the target location for storing the note. Finally,
the template itself, a string with %-escapes to fill in information
based on time and context.

When you call M-x org-capture, Org will prompt for a key to select the
template (if you have more than one template) and then prepare the
buffer

During expansion of the template, special %-escapes1 allow dynamic
insertion of content. Here is a small selection of the possibilities,
consult the manual for more.

- %a          annotation, the link created with org-store-link
- %i          initial content, region when capture is called with C-u.
- %t          timestamp, date only
- %T          timestamp with date and time
- %u, %U      like the above, but inactive timestamps

*** Narrowing to a node or block

When the org files get bigger, it can get confusing when suddenly the
window scroll away. It takes time to find the node back, especially if
you jumped in from a link and you have not navigated to it.

By narrowing the buffer to the subtree or block you can avoid
inadvertent moving away or doing changes to other parts of the file.

- C-x n s : (org-narrow-to-subtree) Narrow buffer to current subtree.
- C-x n b : (org-narrow-to-block) Narrow buffer to current block.
- C-x n w : (widen) Widen buffer to remove narrowing.

*** Refile targets
#+BEGIN_SRC emacs-lisp
  ; Targets include this file and any file contributing to the agenda
  ; up to 2 levels deep
  (setq org-refile-targets (quote ((nil :maxlevel . 2)
                                 (org-agenda-files :maxlevel . 2))))

  ; Targets start with the file name - allows creating level 1 tasks
  (setq org-refile-use-outline-path (quote file))

  ; Targets complete directly with IDO
  ;  (setq org-outline-path-complete-in-steps nil)

  ; Allow refile to create parent tasks with confirmation
  (setq org-refile-allow-creating-parent-nodes (quote confirm))

  ; helm does not show headers as refile target if this is not nil
  (setq org-outline-path-complete-in-steps nil)

#+END_SRC

#+RESULTS:

# *** Use IDO for for org
# #+BEGIN_SRC emacs-lisp

# (setq org-completion-use-ido t)
# #+END_SRC

*** Do not dim blocked tasks

#+BEGIN_SRC emacs-lisp
(setq org-agenda-dim-blocked-tasks t)
#+END_SRC

*** Clocking setup
#+BEGIN_SRC emacs-lisp

; Resume clocking tasks when emacs is restarted
(setq org-clock-persist 'history)
(org-clock-persistence-insinuate)
; Resume clocking task on clock-in if the clock is open
(setq org-clock-in-resume t)
; Do not change task states when clocking in
(setq org-clock-in-switch-to-state nil)
; Separate drawers for clocking and logs
(setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))

;; Save clock data and state changes and notes in the LOGBOOK drawer
(setq org-clock-into-drawer t)

;; Sometimes I change tasks I'm clocking quickly - this removes
;; clocked tasks with 0:00 duration
(setq org-clock-out-remove-zero-time-clocks t)

;; Clock out when moving task to a done state
(setq org-clock-out-when-done t)

;; Save the running clock and all clock history when exiting Emacs,
;; load it on startup
(setq org-clock-persist
    (quote history))

;; Enable auto clock resolution for finding open clocks
(setq org-clock-auto-clock-resolution
    (quote when-no-clock-is-running))

;; Include current clocking task in clock reports
(setq org-clock-report-include-clocking-task t)

;; Agenda log mode items to display (clock time only by default)
(setq org-agenda-log-mode-items (quote (clock)))

;; Agenda clock report parameters
(setq org-agenda-clockreport-parameter-plist
    (quote (:link t :maxlevel 5 :fileskip0 t :compact t)))


#+END_SRC

*** Support pomodoro workflow

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-modules 'org-timer)
(setq org-timer-default-timer 25)
(add-hook 'org-clock-in-hook
      '(lambda ()
         (if (not org-timer-current-timer)
             (org-timer-set-timer))))
#+END_SRC


*** Tags with fast selection keys
#+BEGIN_SRC emacs-lisp

(setq org-tag-alist (quote ((:startgroup)
                        ("@errand" . ?e)
                        ("@office" . ?o)
                        ("@home" . ?h)
                        (:endgroup)
                        ("PHONE" . ?p)
                        ("QUOTE" . ?q)
                        ("WAITING" . ?w)
                        ("PERSONAL" . ?P)
                        ("WORK" . ?W)
                        ("ORG" . ?O)
                        ("SNAMELLIT" . ?S)
                        ("MELEXIS" . ?M)
                        ("crypt" . ?E)
                        ("NOTE" . ?n)
                        ("CANCELLED" . ?C)
                        ("FLAGGED" . ??))))

; Allow setting single tags without the menu
(setq org-fast-tag-selection-single-key (quote expert))

; For tag searches ignore tasks with scheduled and deadline dates
(setq org-agenda-tags-todo-honor-ignore-options t)
#+END_SRC

***
***
***
***
***
***
***
***


*** checklists

#+BEGIN_SRC emacs-lisp
(defun pti-catlines (lines)
(mapconcat 'identity lines "\n"))

#+END_SRC


*** Calendar
**** Calendar files

Calendar files are set in the variable org-agenda-files.

However it is best to let this be managed with custom.el.

- C-c [ : add current file to front of the list
- C-c ] : remove the file of the list
- C-c a t : show current todo list over all the files.


*** Org Babel
**** Org Babel load support for different languages

#+BEGIN_SRC emacs-lisp

(org-babel-do-load-languages
'org-babel-load-languages
'((emacs-lisp . t)
(dot . t)
(ditaa . t)
(R . t)
(python . t)
(ruby . t)
(gnuplot . t)
(clojure . t)
(sh . t)
(org . t)
(plantuml . t)
(latex . t)
(sql . t)
(sqlite . t)
(clojure . t)
(js . t)))`%

; set language support using customize. Does not get picked up here.

; Do not prompt to confirm evaluation
; This may be dangerous - make sure you understand the consequences
; of setting this -- see the docstring for details
(setq org-confirm-babel-evaluate nil)

#+END_SRC

**** Org Babel setup for fancy graphics etc

#+BEGIN_SRC emacs-lisp
(setq org-ditaa-jar-path "~/Dropbox/Tools/ditaa0_9.jar")
(setq org-plantuml-jar-path "~/Dropbox/Tools/plantuml.jar")

(add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+END_SRC


*** Latex Support

Org mode has great support to create nice looking documents and
presentations using the LaTeX typesetting system.

#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
(require 'ox-beamer)
#+END_SRC

To export an org file as a pdf several shortcuts are very useful:

- C-c C-e l o  : generate and show a pdf document
- C-c C-e l O  : generate and show a pdf presentation

There is a user friendly menu which is actived by C-c C-e and helps
the user with the other options.

Note that for presentations in is not enough of indicating the beamer
class to use. You also need to use the special export commands or the
files end up as ugly documents instead of nice presentations.


**** Add support for Snamellit classes

In order to simplify the creation of good looking documents for
Snamellit, I created a number of extensions of the standard latex
classes.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
           '("snm-article" "\\documentclass{snm-article}
[NO-DEFAULT-PACKAGES]
[NO-PACKAGES]"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-latex-classes
           '("snm-report" "\\documentclass{snm-report}
[NO-DEFAULT-PACKAGES]
[NO-PACKAGES]"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))

(add-to-list 'org-latex-classes
           '("snm-report" "\\documentclass{snm-report}
[NO-DEFAULT-PACKAGES]
[NO-PACKAGES]"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))

(add-to-list 'org-latex-classes
           '("snm-book" "\\documentclass{snm-book}
[NO-DEFAULT-PACKAGES]
[NO-PACKAGES]"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))

(add-to-list 'org-latex-classes
           '("snm-beamer" "\\documentclass{snm-beamer}
[NO-DEFAULT-PACKAGES]
[NO-PACKAGES]"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))

#+END_SRC

#+RESULTS:
| snm-beamer  | \documentclass{snm-beamer}\n  [NO-DEFAULT-PACKAGES]\n  [NO-PACKAGES]  | (\section{%s} . \section*{%s}) | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) |                                      |                                            |
| snm-book    | \documentclass{snm-book}\n  [NO-DEFAULT-PACKAGES]\n  [NO-PACKAGES]    | (\part{%s} . \part*{%s})       | (\chapter{%s} . \chapter*{%s})       | (\section{%s} . \section*{%s})             | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) |
| snm-report  | \documentclass{snm-report}\n  [NO-DEFAULT-PACKAGES]\n  [NO-PACKAGES]  | (\part{%s} . \part*{%s})       | (\chapter{%s} . \chapter*{%s})       | (\section{%s} . \section*{%s})             | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) |
| snm-article | \documentclass{snm-article}\n  [NO-DEFAULT-PACKAGES]\n  [NO-PACKAGES] | (\section{%s} . \section*{%s}) | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) | (\paragraph{%s} . \paragraph*{%s})   | (\subparagraph{%s} . \subparagraph*{%s})   |
| mlx-beamer  | \documentclass{mlx-beamer}\n  [NO-DEFAULT-PACKAGES]\n  [NO-PACKAGES]  | (\section{%s} . \section*{%s}) | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) |                                      |                                            |
| mlx-book    | \documentclass{mlx-book}\n  [NO-DEFAULT-PACKAGES]\n  [NO-PACKAGES]    | (\part{%s} . \part*{%s})       | (\chapter{%s} . \chapter*{%s})       | (\section{%s} . \section*{%s})             | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) |
| mlx-report  | \documentclass{mlx-report}\n  [NO-DEFAULT-PACKAGES]\n  [NO-PACKAGES]  | (\part{%s} . \part*{%s})       | (\chapter{%s} . \chapter*{%s})       | (\section{%s} . \section*{%s})             | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) |
| mlx-article | \documentclass{mlx-article}\n  [NO-DEFAULT-PACKAGES]\n  [NO-PACKAGES] | (\section{%s} . \section*{%s}) | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) | (\paragraph{%s} . \paragraph*{%s})   | (\subparagraph{%s} . \subparagraph*{%s})   |
| beamer      | \documentclass[presentation]{beamer}                                  | (\section{%s} . \section*{%s}) | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) |                                      |                                            |
| article     | \documentclass[11pt]{article}                                         | (\section{%s} . \section*{%s}) | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) | (\paragraph{%s} . \paragraph*{%s})   | (\subparagraph{%s} . \subparagraph*{%s})   |
| report      | \documentclass[11pt]{report}                                          | (\part{%s} . \part*{%s})       | (\chapter{%s} . \chapter*{%s})       | (\section{%s} . \section*{%s})             | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) |
| book        | \documentclass[11pt]{book}                                            | (\part{%s} . \part*{%s})       | (\chapter{%s} . \chapter*{%s})       | (\section{%s} . \section*{%s})             | (\subsection{%s} . \subsection*{%s}) | (\subsubsection{%s} . \subsubsection*{%s}) |

**** Add support for Melexis classes

In order to simplify the creation of good looking documents for use in
Melexis I created a number of extensions of the standard latex
classes.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
           '("mlx-article" "\\documentclass{mlx-article}
[NO-DEFAULT-PACKAGES]
[NO-PACKAGES]"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
             ("\\paragraph{%s}" . "\\paragraph*{%s}")
             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(add-to-list 'org-latex-classes
           '("mlx-report" "\\documentclass{mlx-report}
[NO-DEFAULT-PACKAGES]
[NO-PACKAGES]"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))

(add-to-list 'org-latex-classes
           '("mlx-book" "\\documentclass{mlx-book}
[NO-DEFAULT-PACKAGES]
[NO-PACKAGES]"
             ("\\part{%s}" . "\\part*{%s}")
             ("\\chapter{%s}" . "\\chapter*{%s}")
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))

(add-to-list 'org-latex-classes
           '("mlx-beamer" "\\documentclass{mlx-beamer}
[NO-DEFAULT-PACKAGES]
[NO-PACKAGES]"
             ("\\section{%s}" . "\\section*{%s}")
             ("\\subsection{%s}" . "\\subsection*{%s}")
             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))

#+END_SRC

**** Source Code Highlighting

Since I deal with a lot of source-code I like to have it nicely formatted.
One of the best ways is to use the minted option which uses the python
*pygmentize* script. This program must be installed and on the
standard search path.

#+BEGIN_SRC emacs-lisp
  ;; Setup minted fancy listings
  (setq org-latex-listings 'minted)
  (setq org-latex-custom-lang-environments
      '(
  ;;      (emacs-lisp "common-lispcode")
        ))
  (setq org-latex-minted-options
      '(("frame" "lines")
        ("fontsize" "\\scriptsize")
        ("linenos" "")
        ("breaklines" "true")
        ("breakanywhere" "true")))

  ;; Add -shell-escape to enable pygmentize to be called
  (let ((cmd (mapconcat
            'identity
            '("lualatex"
              "-shell-escape"
              "-interaction nonstopmode"
              "-output-directory %o"
              "%f")
            " ")))
  (setq
   org-latex-pdf-process
   ;; run command 3x to update indexes and such
   (list cmd cmd cmd)))
#+END_SRC

#+RESULTS:
| lualatex -shell-escape -interaction nonstopmode -output-directory %o %f | lualatex -shell-escape -interaction nonstopmode -output-directory %o %f | lualatex -shell-escape -interaction nonstopmode -output-directory %o %f |

*** Integration with other systems
**** Org Mobile

Org Mobile allows me to take my org files on my iPhone.

It exchanges the files in both directions using Dropbox.

#+BEGIN_SRC emacs-lisp
  ;; Set to the name of the file where new notes will be stored
  (setq org-mobile-inbox-for-pull "~/org/flagged.org")
  ;; Set to <your Dropbox root directory>/Apps/MobileOrg.
  (setq org-mobile-directory "~/Dropbox/Apps/MobileOrg")
  (setq org-mobile-files
      (quote
       (org-agenda-files
        "~/org/todo.org"
        "~/org/emacs.org"
        "~/org/pfus.org")))

  ;; org-mobile integration and automation.
  ;;
  ;; wait 60 min between auto updates to avoid losing time
  ;; when "catching up"
  (setq  org-mobile-last-sync 0)

  (defun pti-set-difference (a b)
  (delq nil
   (mapcar
    (lambda (x)
      (when (not (and (member x a) (member x b))) x))
    (append a b))))

  (defun open-buffer-names ()
  (mapcar 'buffer-name (buffer-list)))

  (defun restore-buffers (fn)
  (let ((old-open-buffers (open-buffer-names)))
    (funcall fn)
    (dolist ( buffer-name
              (pti-set-difference (open-buffer-names)
                                  old-open-buffers))
      (kill-buffer buffer-name))))

  (defun org-mobile-pullpush nil nil
  ( if (> (- (float-time) org-mobile-last-sync) 3600)
     (progn
        (restore-buffers 'org-mobile-pull)
        (restore-buffers 'org-mobile-push)
        (setq org-mobile-last-sync (float-time))))
  )

  ;; My main desktop systems are Macs for now
  (if (eq system-type 'darwin)
      (progn
       ;; sync at start, finish and in between 2x p hr
       (add-hook 'after-init-hook
                 (lambda ()
                   (restore-buffers 'org-mobile-pull)))
       (add-hook 'kill-emacs-hook
                 (lambda ()
                   (restore-buffers 'org-mobile-push)))
       (run-at-time "00:29" 7200 'org-mobile-pullpush)))
#+END_SRC

#+RESULTS:

**** jira integration
#+BEGIN_SRC emacs-lisp
  (require-packages 'org-jira)
  (setq jiralib-url "https://jira.melexis.com/jira")
  (setq org-jira-working-dir "~/org/melexis/jira")

#+END_SRC

#+RESULTS:
: ~/org/melexis/jira

**** org-protocol handlers with browsers

Load the handlers for the browser protocol extenders.

This allows emacsclient to do interesting stuff with URL protocols

e.g.

#+BEGIN_SRC bash
$ macsclient org-protocol://store-link:...
                ...//http:%2F%2Flocalhost%2Findex.html/The%20title
#+END_SRC

Stores a link to *http://localhost/index.html* in the kill ring to be
pasted in as a org-link, or as text.

#+BEGIN_SRC emacs-lisp
(require 'org-protocol)
#+END_SRC

#+RESULTS:
: org-protocol

The problem is that on the Mac you apparently need to use a special
app to trigger emacsclient in order to register the URL handler. And
this app does not work with the homebrew emacs version.

It does work for Aquamacs and this program has the emacs bin directory
with the emacsclient in the *Contents/MacOS/* folder next to the Emacs
binary.

When we create a symbolic link from /usr/local/Cellar/emacs/HEAD/bin
to /Applications/Emacs.app/Contents/MacOS/bin, and then another link
from /Applications/Emacs.app to /Applications/Aquamacs.app then the
EmacsClient.app does not know the difference.

This was successfully tested on Firefox.

**** taskjuggler project management

The taskjuggler is an export target in the contrib folder.

#+BEGIN_SRC emacs-lisp
  (let ((tj3-file "~/.emacs.d/vendor/org-mode/contrib/lisp/ox-taskjuggler.el"))
    (when (file-exists-p tj3-file)
      (load-file tj3-file)
      (add-to-list 'org-export-backends 'taskjuggler)))
#+END_SRC

#+RESULTS:
| taskjuggler | ascii | html | icalendar | latex |

**** groovy babel support

The taskjuggler is an export target in the contrib folder.

#+BEGIN_SRC emacs-lisp
  (let ((ob-groovy "~/.emacs.d/vendor/org-mode/contrib/lisp/ob-groovy.el"))
    (when (file-exists-p ob-groovy)
      (load-file ob-groovy)
      (add-to-list 'org-export-backends 'taskjuggler)))
#+END_SRC

#+RESULTS:

** Markdown

*** Support markdown files

#+BEGIN_SRC emacs-lisp
  (require-packages 'markdown-mode)

  (setq auto-mode-alist (cons '("\\.markdown" . markdown-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.md" . markdown-mode) auto-mode-alist))

  (add-hook 'markdown-mode-hook '(lambda() (auto-fill-mode)))
#+END_SRC

*** Modify TAB behavior for markdown

Markdown mode and Yasnippet fight for the tab key.

Markdown cycles the indentation and yasnippet wants to expand
snippets.

This code will try to expand a snippet and if this fails it does the
markdown cycling.

#+BEGIN_SRC emacs-lisp

(defun my-markdown-tab ()
(interactive)
(let ((yas-fallback-behavior 'return-nil)) (yas-expand))
(markdown-cycle))

(add-hook
'markdown-mode-hook
'(lambda ()
(define-key markdown-mode-map (kbd "A-r") 'markdown-preview)
(define-key markdown-mode-map (kbd "<tab>") 'my-markdown-tab)
(outline-minor-mode)))

#+END_SRC

Notice also that the *A-r* shortcut shows a preview of the document in
the browser.

# ** ASCII art with Artist

# Artist mode allows to create fancy ASCII art.

# Add ido support to select operations and settinngs

# #+BEGIN_SRC emacs-lisp
#   ;;; integrate ido with artist-mode
#   (defun artist-ido-select-operation (type)
#     "Use ido to select a drawing operation in artist-mode"
#     (interactive
#      (list
#       (ido-completing-read
#        "Drawing operation: "
#        (list "Pen" "Pen Line" "line" "straight line" "rectangle"
#              "square" "poly-line" "straight poly-line" "ellipse"
#              "circle" "text see-thru" "text-overwrite" "spray-can"
#              "erase char" "erase rectangle" "vaporize line"
#              "vaporize lines" "cut rectangle" "cut square"
#              "copy rectangle" "copy square" "paste" "flood-fill"))))
#     (artist-select-operation type))

#   (defun artist-ido-select-settings (type)
#     "Use ido to select a setting to change in artist-mode"
#     (interactive
#      (list
#       (ido-completing-read
#        "Setting: "
#        (list "Set Fill" "Set Line" "Set Erase" "Spray-size"
#              "Spray-chars" "Rubber-banding" "Trimming" "Borders"))))
#     (if (equal type "Spray-size")
#         (artist-select-operation "spray set size")
#       (call-interactively
#        (artist-fc-get-fn-from-symbol
#         (cdr
#          (assoc type
#                 '(("Set Fill" . set-fill)
#                   ("Set Line" . set-line)
#                   ("Set Erase" . set-erase)
#                   ("Rubber-banding" . rubber-band)
#                   ("Trimming" . trimming)
#                   ("Borders" . borders)
#                   ("Spray-chars" . spray-chars))))))))
#   (add-hook 'artist-mode-init-hook
#             (lambda ()
#               (define-key artist-mode-map
#                 (kbd "C-c C-a C-o") 'artist-ido-select-operation)
#               (define-key artist-mode-map
#                 (kbd "C-c C-a C-c") 'artist-ido-select-settings)))

# #+END_SRC

** HTML and SGML
*** escape html/xml code for inclusion

#+BEGIN_SRC emacs-lisp
  (defun unhtml (start end)
    (interactive "r")
    (save-excursion
      (save-restriction
        (narrow-to-region start end)
        (goto-char (point-min))
        (replace-string "&" "&amp;")
        (goto-char (point-min))
        (replace-string "<" "&lt;")
        (goto-char (point-min))
        (replace-string ">" "&gt;")
        )))
#+END_SRC

#+RESULTS:
: unhtml

*** Live browser integration

Send HTML elements directly to the browser using *skewer-mode*
(installed in the integration section).

C-M-x: Load the HTML tag immediately around the point.
** Xml files

*** Autoloading

#+BEGIN_SRC emacs-lisp
(add-to-list
'auto-mode-alist
(cons
(concat
 "\\."
 (regexp-opt '("xml" "xsd" "sch" "rng" "xslt" "svg" "rss") t)
 "\\'")
'nxml-mode))

(setq magic-mode-alist
    (cons '("<\\?xml " . nxml-mode)
          magic-mode-alist))

(fset 'xml-mode 'nxml-mode)

#+END_SRC

** Yaml files

Enable yaml mode for yaml files and remap return to indent on a new
line.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
(add-hook 'yaml-mode-hook
  '(lambda ()
     (define-key yaml-mode-map "\C-m" 'newline-and-indent)
     (add-untabify-before-save)
))
#+END_SRC

** 3D Modelling with SCAD

There is a programming language like 3D modeller which is popular in
the 3D printing world. I downloaded an extension for it in the
*vendor* directory.

#+BEGIN_SRC emacs-lisp
(vendor 'scad)
(add-hook 'scad-mode 'add-untabify-before-save)
#+END_SRC

** Content Creation Done

#+BEGIN_SRC emacs-lisp
  (message "Content Creation section done.")
#+END_SRC

* Programming Tools

** Version Control

Map magit-status so it is only 1 global keystroke away.

- C-x g:  magit-status

#+BEGIN_SRC emacs-lisp
  (require-packages 'magit)
  (global-set-key "\C-xg" 'magit-status)
  (setq magit-last-seen-setup-instructions "1.4.0")
  (setq magit-emacsclient-executable (executable-find "emacsclient"))
#+END_SRC

#+RESULTS:
: /usr/local/bin/emacsclient

** Project Support

Projectile offers project support like searching files in the current
project.

A project is essentially a folder structure below a root which is
identified by the presence of a magic file, typically a build file, or
VCS folder.

- C-c p f :   Search file in project
- C-c p p :   Switch project

#+BEGIN_SRC emacs-lisp
(require-packages 'projectile)
(projectile-global-mode)
#+END_SRC

#+RESULTS:
: t

Projectile has a special module to integrate with helm and replaces
several commands with helm enabled ones. Enable this alternative
keymap.

#+BEGIN_SRC emacs-lisp
  (require-packages 'helm-projectile)
  (setq projectile-completion-system 'helm)
  (helm-projectile-on)
#+END_SRC


** Makefiles

Makefiles rely on tabs to show the difference between targets and
commands.

This is stupid and ugly, but so be it. So we have to relax our
*spaces-no-tabs* rule to respect it's syntax.

#+BEGIN_SRC emacs-lisp
;; leave tabs in the file do not add the untabify hook here

#+END_SRC

** Programming Tools done

#+BEGIN_SRC emacs-lisp
  (message "Programming Tools section done")
#+END_SRC


* Applications
** Dired File Manager

By default emacs dumps a directory listing in another buffer when the
keycode for directory listing ( C-x C-r )is pressed. However emacs
comes with a full fledged file manager. This is far more useful under
this code

#+BEGIN_SRC emacs-lisp
; prefer dired over dumping dir list to buffer
(global-set-key "\C-x\C-d" 'dired)
#+END_SRC

#+RESULTS:
: dired


** Rcirc IRC client

#+BEGIN_SRC emacs-lisp
  ; settings for rcirc IRC client

  ;; Don't print /away messages.
  ;; This does not require rcirc to be loaded already,
  ;; since rcirc doesn't define a 301 handler (yet).
  (defun rcirc-handler-301 (process cmd sender args)
  "/away message handler.")

  ;; Turn on spell checking.
  (add-hook 'rcirc-mode-hook (lambda ()
                           (flyspell-mode 1)))

  ;; Keep input line at bottom.
  (add-hook 'rcirc-mode-hook
          (lambda ()
            (set (make-local-variable 'scroll-conservatively)
                 8192)))

  ;; Join these channels at startup.
  (setq rcirc-server-alist
      '(("irc.freenode.net"
         :channels ("#emacs"
                    "#rcirc"
                    "#clojure"
                    "#cucumber"
                    "#leiningen"
                    "#ubuntu-bugs"))
        ("irc.geekshed.net"
         :channels ("#jupiterbroadcasting"))
        ("irc.codehaus.org"
         :channel ("#activemq"))))


#+END_SRC

When starting *rcirc* it will open connections to the servers listed
in the *rcirc-server-alist* and open a buffer for each of the channels
listed.


** Gnus News and Mail reading

#+BEGIN_SRC emacs-lisp
(setq gnus-select-method '(nntp "newsgroups.telenet.be"))

(setq gnus-secondary-select-methods
    '((nnimap "gmail-melexis"
              (nnimap-address "imap.gmail.com")
              (nnimap-server-port 993)
              (nnimap-stream ssl))))

(setq message-send-mail-function 'smtpmail-send-it)

#+END_SRC

Note that in private.el are the mail accounts like:

#+BEGIN_SRC emacs-lisp
;; gnus email personal config
(setq smtpmail-starttls-credentials '(("XXXX.XXXXX.XXX" 587
                                     nil nil))
    smtpmail-auth-credentials '(("XXXX.XXXXX.XXX" 587
                                 "XXX@XXXXXXXX.XXX" nil))
    smtpmail-default-smtp-server "XXXX.XXXXX.XXX"
    smtpmail-smtp-server "XXXX.XXXXX.XXX"
    smtpmail-smtp-service 587
    smtpmail-local-domain "XXXXXXX.XXX")

#+END_SRC

** Applications done

#+BEGIN_SRC emacs-lisp
  (message "Applications section done")
#+END_SRC

* Integration with other systems

** with Google Calendar

Org-mode is awesome for task management however to do effective task
scheduling we would need to have the calendar included too.

The process for importing your google calendar is [[http://orgmode.org/worg/org-tutorials/org-google-sync.html][documented on Worg]].

It uses the *ical2org.awk* script by Eric S. Fraga. I added a
postamble with some file local variables to make the file read-only,
to avoid complications, and to autorevert the file on updates.

#+BEGIN_SRC awk

  END {
      # postamble

      # print a local variable section to auto revert this file
      print ""
      print ""
      print "# Local Variables:"
      print "# buffer-read-only: 1"
      print "# eval: (auto-revert-mode)"
      print "# End:"
  }

#+END_SRC

This makes it a lot easier when running in a cron job.

I configured a recurring job which synchs every hour.

Now make sure the calendar is in the calendar list. Go to the file and
type *C-c [*.

Then you can see your calendar with tasks etc, by typing *C-c a a*

Note: make sure this section is not to close to the end of the file as
emacs will mistake the awk snippet as a real varialble section.

** Integration with host system

*** Consistent search path for programs

A particular pain point is that graphical apps do not have the same
path setup as the command lines in the terminal, because the rc files
have not yet run.

We can get the path by executing the user configured shell and
printing the path.

I usually use *zsh* on my machines, but sometimes on remote machines I
use the default *bash* shell. This way works both ways.

#+BEGIN_SRC emacs-lisp
(defun set-exec-path-from-shell-PATH ()
(let ((path-from-shell (shell-command-to-string "TERM=vt100 $SHELL -i -c 'echo $PATH'")))
  (setenv "PATH" path-from-shell)
  (setq exec-path (split-string path-from-shell path-separator))))

;; when running in a GUI reset path from an initialized shell
(when window-system (set-exec-path-from-shell-PATH))


#+END_SRC

Similarly the apps when started in a graphical environment lack a
current directory. Let's start in the home folder.

#+BEGIN_SRC emacs-lisp
(cd "~")
#+END_SRC

*** OSX quirks

#+BEGIN_SRC emacs-lisp

#+END_SRC

*** Browser Integration

**** Skewer mode

Provides live interaction with JavaScript, CSS, and HTML in a web
browser. Expressions are sent on-the-fly from an editing buffer to be
evaluated in the browser, just like Emacs does with an inferior Lisp
process in Lisp modes.

#+BEGIN_SRC emacs-lisp
(require-packages 'skewer-mode)
(skewer-setup)
#+END_SRC

**** Enable emacs to edit textareas

There are browser plugins to allow emacs to be used to edit textareas.

This use a server running in emacs to interact with.

#+BEGIN_SRC emacs-lisp
(require-packages 'edit-server)
(edit-server-start)
#+END_SRC

#+RESULTS:

** with GitHub

Gist buffer, always useful for collab.

#+BEGIN_SRC emacs-lisp
(global-set-key "\C-c\C-g" 'gist-buffer-confirm)
#+END_SRC

** with Postgresql

The default implementation of *postgresql* in org-babel is not
consistent with the documentation on the web.

In fact it only uses the *cmdline* parameter and ignores the *dbhost*,
*dbuser*, *dbpassword* and *database* parameters. There is no real
reason not to support it, but it just does not.

I patched it once, but forgot to send the patch upstream.

Currently the workaround consists of adding all this information to
the *cmdline*  parameter.

e.g.

#+BEGIN_SRC org
  ,#+name: get-risk-data
  ,#+header: :engine postgresql
  ,#+header: :cmdline -h postgresql.colo.elex.be -Ujira jira
  ,#+BEGIN_SRC sql
      select
           p.pname
         , p.pkey || '-' || i.issuenum as pkey
         , rio.customvalue as riv
      ...
  ,#+END_SRC
#+END_SRC

Note that there is no password in the configuration, just the way I
like it.

Actually the passwords are in a file *~/.pgpass* which contains lines
in the following format:

: hostname:portnumber:database:username:password

You can use * as a wildcard for databases, probably for other fields
too but I do not know if this makes much sense in practice.

e.g.

#+BEGIN_EXAMPLE
localhost:5432:*:pti:secret
postgresql-test.colo.elex.be:5432:spagobi:spagobi:verysecret
postgresql.colo.elex.be:5432:*:jira:moresecret
#+END_EXAMPLE

This avoids the passwords to be in plain sight in the files which
would be a pain if parts of them are ever exported and published.

** with  docker

*** Get the connection to the docker environment

#+BEGIN_SRC emacs-lisp
  (defun snam/clean-docker-env-value (s)
    "the values are escaped with quotes which have to
     be removed for our use"
    (replace-regexp-in-string "\\\"" "" s))

  (defun snam/docker-environment (script)
    "remove the export statements from the lines which
     were actually intended to be interpreted by bash"
    (mapcar
     (lambda (l)
       (message l)
       (let* ((kv (split-string l "="))
              (key (car kv))
              (val (snam/clean-docker-env-value (cadr kv))))
         (cons key val)))
     (mapcar
      (lambda (s)
        (cadr (split-string s "[ ]+")))                 ; remove export part
      (remove-if-not                                    ; only keep env vars
       (lambda (s) (string-prefix-p "export" s))        ; from output of cmd
       (split-string script "[\r\n]+")))))

  (defun docker-init ()
    "check if docker-machine is on the path and get the
    expected environment from there to allow docker to find
    the docker daemon."
    (message "initializing docker...")
    (let* ((eval-script (shell-command-to-string "docker-machine env dev"))
           (docker-env (snam/docker-environment eval-script)))

      (loop for (key . val) in docker-env
            collect (setenv key val))))

  (docker-init)


#+END_SRC

#+RESULTS:
| 1 | tcp://192.168.99.100:2376 | /Users/pti/.docker/machine/machines/dev | dev |

*** Tramp support for files in containers

This allows to open files in docker containers with tramp using the
_/docker:container_name:/file/name_ syntax

#+BEGIN_SRC emacs-lisp
  ;; Open files in Docker containers like so: /docker:drunk_bardeen:/etc/passwd
  (push
   (cons
    "docker"
    '((tramp-login-program "docker")
      (tramp-login-args (("exec" "-it") ("%h") ("/bin/bash")))
      (tramp-remote-shell "/bin/sh")
      (tramp-remote-shell-args ("-i") ("-c"))))
   tramp-methods)

  (defadvice tramp-completion-handle-file-name-all-completions
    (around dotemacs-completion-docker activate)
    "(tramp-completion-handle-file-name-all-completions \"\" \"/docker:\" returns
      a list of active Docker container names, followed by colons."
    (if (equal (ad-get-arg 1) "/docker:")
        (let* ((dockernames-raw (shell-command-to-string "docker ps | awk '$NF != \"NAMES\" { print $NF \":\" }'"))
               (dockernames (cl-remove-if-not
                             #'(lambda (dockerline) (string-match ":$" dockerline))
                             (split-string dockernames-raw "\n"))))
          (setq ad-return-value dockernames))
      ad-do-it))

  (message "docker tramp integration added.")
#+END_SRC

#+RESULTS:
: tramp-completion-handle-file-name-all-completions

** Integrations done

#+BEGIN_SRC emacs-lisp
  (message "Integration section done")
#+END_SRC

* Final thoughts

#+BEGIN_SRC emacs-lisp
  (message "Snamellit configuration completed.")
#+END_SRC
